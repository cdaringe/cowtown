(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{"./src/logging.mdx":function(e,n,a){"use strict";a.r(n),a.d(n,"default",function(){return g});var o=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),t=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js"),r=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js"),s=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"),l=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"),c=a("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js"),i=a("../../node_modules/react/index.js"),m=a.n(i),p=a("../../node_modules/@mdx-js/tag/dist/index.js"),g=function(e){function n(e){var a;return Object(t.a)(this,n),(a=Object(s.a)(this,Object(l.a)(n).call(this,e))).layout=null,a}return Object(c.a)(n,e),Object(r.a)(n,[{key:"render",value:function(){var e=this.props,n=e.components;Object(o.a)(e,["components"]);return m.a.createElement(p.MDXTag,{name:"wrapper",components:n},m.a.createElement(p.MDXTag,{name:"h1",components:n,props:{id:"logging"}},"logging"),m.a.createElement(p.MDXTag,{name:"ul",components:n},m.a.createElement(p.MDXTag,{name:"li",components:n,parentName:"ul"},"a logging provider should be created as early as possible in your application")),m.a.createElement(p.MDXTag,{name:"p",components:n},"like all functional programming application resources,"),m.a.createElement(p.MDXTag,{name:"ul",components:n},m.a.createElement(p.MDXTag,{name:"li",components:n,parentName:"ul"},"pass the logging resource to all consumers via function arguments")),m.a.createElement(p.MDXTag,{name:"p",components:n},"other languages, such as python, support a system level logger.\nsuch system level loggers, whilst convenient, are also highly stateful and subject\nto unexpected mutation by consumers.  further, doing direct resource imports,\ne.g. ",m.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"import { logger } from './logger'"),", has debatably harmful costs--such as\nforcing you to mock or override default runtime behavior in things like tests,\nwhere you may not care to see log output."),m.a.createElement(p.MDXTag,{name:"ul",components:n},m.a.createElement(p.MDXTag,{name:"li",components:n,parentName:"ul"},"consider a standard log schema & easily parseable format")),m.a.createElement(p.MDXTag,{name:"p",components:n},"such as ",m.a.createElement(p.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"http://ndjson.org"}},"ndjson")," if you plan to use a logging aggregator.\ni like to configure my logger to log in ",m.a.createElement(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"ndjson")," in non-dev environments, and pretty print\nlogs during development."),m.a.createElement(p.MDXTag,{name:"p",components:n},"the following example does not consider:"),m.a.createElement(p.MDXTag,{name:"ul",components:n},m.a.createElement(p.MDXTag,{name:"li",components:n,parentName:"ul"},"what content to log"),m.a.createElement(p.MDXTag,{name:"li",components:n,parentName:"ul"},"what logging provider to use")),m.a.createElement(p.MDXTag,{name:"p",components:n},"that's up to you, friend."),m.a.createElement(p.MDXTag,{name:"blockquote",components:n},m.a.createElement(p.MDXTag,{name:"p",components:n,parentName:"blockquote"},"application logging")),m.a.createElement(p.MDXTag,{name:"pre",components:n},m.a.createElement(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-typescript"}},"// src/bin\nconst config = createConfig(...)\nconst logger = createLogger(config.logging)\n\n// observe the logger shared between server, middlewares, and services\nconst server = await createServer({ config, logger })\nconst services = await createBackgroundServices({ config, logger })\n\n// src/server\n// ...\nasync function createServer ({ config, logger }) {\n  const app = new Koa()\n  const mw = await createMiddlewares({ config, logger })\n  app.use(mw)\n  return app\n}\n\n// src/middleware/cool-mw\nfunction createCoolMw ({ logger }) {\n  logger.debug('creating cool middleware')\n  return (ctx, next) => {\n    logger.warn('(\u2310\u25a0_\u25a0) ( \u2022_\u2022)>\u2310\u25a0-\u25a0 (\u2022_\u2022)')\n    await next()\n    logger.info('(\u2022_\u2022) ( \u2022_\u2022)>\u2310\u25a0-\u25a0 (\u2310\u25a0_\u25a0)')\n  }\n}\n\n// src/util/widget\nconst debug = require('debug')('widget')\nfunction buildWidget (pieces) {\n  // library-esqe code is fine to log from,\n  // but generally **should't use an application-level\n  // logger**. consider modules like `debug`, or\n  // conditional console logging instead.  be weary\n  // of coupling libary code to application code and accidentally\n  // reducing portability of your work.\n  debug(`received ${pieces.length} pieces`)\n  // or\n  if (process.env.NODE_ENV === 'development') {\n    console.info(`received ${pieces.length} pieces`)\n  }\n  return pieces.map(piece => piece.name).join('-')\n}\n")))}}]),n}(m.a.Component);"undefined"!==typeof g&&g&&g===Object(g)&&Object.defineProperty(g,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"src/logging.mdx"}}),"undefined"!==typeof g&&g&&g===Object(g)&&Object.defineProperty(g,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"src/logging.mdx"}}),g.isMDXComponent=!0}}]);
//# sourceMappingURL=src-logging.626372f526a4bd2dcbc8.js.map
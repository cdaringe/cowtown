(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{"./src/manage-configuration.mdx":function(e,n,o){"use strict";o.r(n),o.d(n,"default",function(){return g});var a=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js"),t=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js"),r=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass.js"),i=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js"),c=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js"),s=o("../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits.js"),l=o("../../node_modules/react/index.js"),p=o.n(l),m=o("../../node_modules/@mdx-js/tag/dist/index.js"),g=function(e){function n(e){var o;return Object(t.a)(this,n),(o=Object(i.a)(this,Object(c.a)(n).call(this,e))).layout=null,o}return Object(s.a)(n,e),Object(r.a)(n,[{key:"render",value:function(){var e=this.props,n=e.components;Object(a.a)(e,["components"]);return p.a.createElement(m.MDXTag,{name:"wrapper",components:n},p.a.createElement(m.MDXTag,{name:"h1",components:n,props:{id:"manage-configuration"}},"manage configuration"),p.a.createElement(m.MDXTag,{name:"p",components:n},"there are seemingly inifinite ways to manage configuration.  i generally recommend\nconforming to ",p.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://12factor.net/config"}},"12 factor")," recommendations. however, rather\nthan putting environment variable checks all over your code, prefer a pure and\ntestable strategy."),p.a.createElement(m.MDXTag,{name:"ul",components:n},p.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"create a configuration data-structure on boot, e.g. a ",p.a.createElement(m.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"Config")," object"),p.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"pass ","[slices of]"," configuration deeper into your application as needed"),p.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"attempt to keep your configuration consolidated/centralized"),p.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"attempt to keep your configuration immutable/read-only"),p.a.createElement(m.MDXTag,{name:"li",components:n,parentName:"ul"},"validate configuration (i.e. user input) each time it is created/replaced")),p.a.createElement(m.MDXTag,{name:"p",components:n},"when configuration is managed as suggested, you will not need advanced or\ncomplicated local testing strategies.  simply create configuration (or any resource, really)\nthen pass the resource into modules being tested. this is also often considered\nfunctional ",p.a.createElement(m.MDXTag,{name:"a",components:n,parentName:"p",props:{href:"https://en.wikipedia.org/wiki/Dependency_injection"}},"dependency injection"),"."),p.a.createElement(m.MDXTag,{name:"pre",components:n},p.a.createElement(m.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-typescript"}},"// application-config/server.ts\nimport { create as createConfig, fromEnv } from './config'\nimport Koa from 'koa'\nasync function start () {\n  const app = new Koa()\n  const config = createConfig(fromEnv())\n  // createMiddlewares(config)\n  // createServices({ app, config: config.services })\n  console.log({ config })\n  app.listen(config.port)\n}\nstart()\n\n\n// application-config/config.ts\nimport joi from 'joi'\n\ntype Config = {\n  port: number\n  logLevel: 'debug' | 'info' | 'warn' | 'error' | 'silent'\n}\n\nexport const fromEnv: () => Partial<Config> = () => {\n  const partialConfig: Partial<Config> = {};\n  if (process.env.PORT) partialConfig.port = parseInt(process.env.PORT)\n  if (process.env.LOG_LEVEL) partialConfig.logLevel = process.env.LOG_LEVEL as any\n  return partialConfig\n}\n\n// GOOD\nexport const create: (partial?: Partial<Config>) => Config = (partial = {}) => {\n  // create a complete configuration container, providing universally applicable\n  // defaults/fallbacks\n  const { port, logLevel } = partial\n  const config: Config = {\n    port: port || 8080,\n    logLevel: logLevel || 'warn'\n  }\n  validate(config)\n  return config\n}\n\nexport const validate = (config: Config) => {\n  const res = joi.validate(config, {\n    port: joi.number().min(0),\n    logLevel: joi.any().valid('debug', 'info', 'warn', 'error', 'silent')\n  }, { presence: 'required' })\n  if (res.error) throw res.error\n  return config\n}\n\n// BAD\n// export const config = fromEnv() // not extensible in testing\n// export const config = create(fromEnv()) // not extensible in testing\n\n\n// examples:\n\n// defaults only\n// $ node application-config/server\n//   { config: { port: 8080, logLevel: 'warn' } }\n\n// custom port\n// $ PORT=3333 node application-config/server\n//   { config: { port: 3333, logLevel: 'warn' } }\n\n// [invalid] custom log level\n// $ LOG_LEVEL='bad-level' node application-config/server\n//   ValidationError: child \"logLevel\" fails because [\"logLevel\" must be one of\n//     [debug, info, ... ]]\n")))}}]),n}(p.a.Component);"undefined"!==typeof g&&g&&g===Object(g)&&Object.defineProperty(g,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"src/manage-configuration.mdx"}}),"undefined"!==typeof g&&g&&g===Object(g)&&Object.defineProperty(g,"__filemeta",{enumerable:!0,configurable:!0,value:{name:"MDXContent",filename:"src/manage-configuration.mdx"}}),g.isMDXComponent=!0}}]);
//# sourceMappingURL=src-manage-configuration.ad1c1451b82f83e13e39.js.map